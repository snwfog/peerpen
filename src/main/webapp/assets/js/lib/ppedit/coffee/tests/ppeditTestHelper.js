// Generated by CoffeeScript 1.7.1

/*
Returns the position of the first element in the set of matched
elements relative to the browser viewport.
 */
var addBox, enterText, moveBox, requestDelete, selectRectangle, simulateBoxClick, simulateBoxDblClick, viewPortPosition, waits;

viewPortPosition = function(jQuerySelector) {
  return {
    left: jQuerySelector.offset().left + jQuerySelector.scrollLeft(),
    top: jQuerySelector.offset().top + jQuerySelector.scrollTop()
  };
};


/*
Adds a given number of boxes on an EMPTY box container
 */

addBox = function(numOfBoxes) {
  var i, _i, _ref;
  for (i = _i = 0, _ref = numOfBoxes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    $(".addElementBtn").eq(0).simulate('click');
  }
  return expect($('.ppedit-box')).toHaveLength(numOfBoxes);
};


/*
Simulates moving the passed box
by the specified distance amount, then calls
the callback once the operations is finished.
 */

moveBox = function(boxSelector, distance, callback) {
  var previousPosition;
  previousPosition = viewPortPosition(boxSelector);
  boxSelector.simulate('mousedown', {
    clientX: previousPosition.left + 1,
    clientY: previousPosition.top + 1
  }).simulate("mousemove", {
    clientX: previousPosition.left + 1,
    clientY: previousPosition.top + 1
  }).simulate("mousemove", {
    clientX: previousPosition.left + distance.dx + 1,
    clientY: previousPosition.top + distance.dy + 1
  }).simulate('mouseup', {
    clientX: previousPosition.left + distance.dx + 1,
    clientY: previousPosition.top + distance.dy + 1
  });
  expect(viewPortPosition(boxSelector)).toBeEqualToPosition({
    left: previousPosition.left + distance.dx,
    top: previousPosition.top + distance.dy
  });
  return waits(300, function() {
    if (callback != null) {
      return callback();
    }
  });
};


/*
Simulates a rectangular selection on the passed
canvas with the parameter specified by the passed rect
 */

selectRectangle = function(canvasSelector, rect) {
  return canvasSelector.simulate("mousedown", {
    clientX: rect.topLeft.left,
    clientY: rect.topLeft.top
  }).simulate("mousemove", {
    clientX: rect.topLeft.left,
    clientY: rect.topLeft.top
  }).simulate("mousemove", {
    clientX: rect.topLeft.left + rect.size.width,
    clientY: rect.topLeft.top + rect.size.height
  }).simulate("mouseup", {
    clientX: rect.topLeft.left + rect.size.width,
    clientY: rect.topLeft.top + rect.size.height
  });
};


/*
Simulates entering the specified text into the passed box
 */

enterText = function(box, text) {
  return simulateBoxDblClick(box, function() {
    expect(box).toBeFocused();
    return box.simulate("key-sequence", {
      sequence: text,
      callback: function() {
        return expect(box).toHaveHtml(text);
      }
    });
  });
};


/*
Simulates ctrl/cmd + delete
 */

requestDelete = function() {
  $('.ppedit-box-container').simulate('key-combo', {
    combo: 'ctrl+46'
  });
  return $('.ppedit-box-container').simulate('key-combo', {
    combo: 'meta+8'
  });
};


/*
Simulates click on a box

  @param selector the selector matching a set of boxes
  @param callback the callback to be called after the click is performed
 */

simulateBoxClick = function(selector, callback) {
  selector.simulate('mousedown');
  selector.simulate('mouseup');
  return waits(300, callback);
};


/*
Simulates doubleclick on a box

  @param selector the selector matching a set of boxes
  @param callback the callback to be called after the doubleclick is performed
 */

simulateBoxDblClick = function(selector, callback) {
  selector.simulate('mousedown');
  selector.simulate('mouseup');
  selector.simulate('mousedown');
  selector.simulate('mouseup');
  return waits(300, callback);
};


/*
Executes the passed callback after waiting for
the passed specified amount
 */

waits = function(amount, callback) {
  var done;
  done = false;
  runs((function() {
    return setTimeout((function() {
      return done = true;
    }), amount);
  }));
  waitsFor((function() {
    return done;
  }), "The operation should run in under " + amount + " minutes.", amount + 500);
  return runs((function() {
    return callback();
  }));
};
